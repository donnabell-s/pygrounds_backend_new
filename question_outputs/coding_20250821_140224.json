[
  {
    "id": 1979,
    "question_text": "Print a secret message with asterisk borders",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "master",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_secret_message",
      "sample_input": "('Hello',)",
      "sample_output": "*********\n* Hello *\n*********",
      "hidden_tests": [
        {
          "input": "('Python',)",
          "expected_output": "**********\n* Python *\n**********"
        },
        {
          "input": "('Debug',)",
          "expected_output": "*********\n* Debug *\n*********"
        }
      ],
      "buggy_code": "def print_secret_message(message):\n    border = '*' * len(message)\n    print(border)\n    print(f'* {message} *')\n    print(border)",
      "buggy_question_text": "Message appears without proper border formatting",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 1980,
    "question_text": "Print a secret message with asterisk borders",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_secret_message",
      "sample_input": "('Hello',)",
      "sample_output": "************\n*  Hello   *\n************",
      "hidden_tests": [
        {
          "input": "('Python',)",
          "expected_output": "************\n*  Python  *\n************"
        },
        {
          "input": "('Debug',)",
          "expected_output": "************\n*   Debug  *\n************"
        }
      ],
      "buggy_code": "def print_secret_message(message):\n    border = '*' * 10\n    print(border)\n    print(f'*  {message}  *')\n    print(border)",
      "buggy_question_text": "Message appears without proper border formatting",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 1981,
    "question_text": "Format user input as title case with proper spacing",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "master",
    "topic": "Basic Input and Output",
    "subtopic": "Best Practices for User-Friendly I/O",
    "game_data": {
      "function_name": "format_user_title",
      "sample_input": "('john doe',)",
      "sample_output": "John Doe",
      "hidden_tests": [
        {
          "input": "('mARY jANE',)",
          "expected_output": "Mary Jane"
        },
        {
          "input": "('dr.strange',)",
          "expected_output": "Dr. Strange"
        },
        {
          "input": "('',)",
          "expected_output": ""
        }
      ],
      "buggy_code": "def format_user_title(name):\n    return name.upper()",
      "buggy_question_text": "Function returns incorrect capitalization and spacing for multi-word inputs",
      "subtopic_names": [
        "Best Practices for User-Friendly I/O"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Best Practices for User-Friendly I/O\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention est"
    },
    "created_at": null
  },
  {
    "id": 1982,
    "question_text": "Convert mixed input types to float for calculations",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "master",
    "topic": "Basic Input and Output",
    "subtopic": "Handling Input Types (Converting to int, float, etc.)",
    "game_data": {
      "function_name": "calculate_average",
      "sample_input": "('5', '3.5', '7')",
      "sample_output": "5.166666666666667",
      "hidden_tests": [
        {
          "input": "('10', '15.5', '20')",
          "expected_output": "15.166666666666666"
        },
        {
          "input": "('abc', '5', '10')",
          "expected_output": "ValueError"
        },
        {
          "input": "('3.14', '2.71', '1.618')",
          "expected_output": "2.489333333333333"
        }
      ],
      "buggy_code": "def calculate_average(*values):\n    total = 0\n    for val in values:\n        total += float(val)\n    return total / len(values)",
      "buggy_question_text": "Function crashes when input contains non-numeric strings",
      "subtopic_names": [
        "Handling Input Types (Converting to int, float, etc.)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Handling Input Types (Converting to int, float, etc.)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 3\n\nLEARNING CONTENT:\n--- Concept ---\nnumeric tower, 279 numeric types checking for convertibility, 468, 480 emulating using special methods, 9-12 hashability of, 84 support for, 479 NumPy, 64-67 O object references aliasing, 204-208 deep copies, 211-213 del and garbage collection, 219-221 distinction between objects and their names, 201 function parameters as references, 213-218 further reading on, 224 immutability and, 221 overview of, 223 shallow copies, 208-211 Soapbox discussion, 225 variables as labels versus boxes, 202-204 objects callable objects, 237-239, 598-599 first-class, 231 flexible object creation, 843-845 mutable, 225 treating functions like, 232-234 user-defined callable objects, 239 operator module, 243-247 operator overloading augmented assignment operators, 580-585 basics of, 562 further reading on, 587 infix operator method names, 576 infix operators, 561 overloading * for scalar multiplication, 572-574 overloading + for vector addition, 566-572 overview of, 585 rich comparison operators, 577-580 significant changes to, 562 Soapbox discussion, 588 topics covered, 562 unary operators, 563-566 using @ as infix operator, 574-576 Optional type, 270 OR-patterns,\n\nDocument: Fluent Python\n--- Concept ---\nChapter Summary | 481 protocols is with static type checkers, which can take into account type hints to make structural typing more reliable. Next we talked about the design and coding of a static protocol and how to extend it. The chapter ended with “The numbers ABCs and Numeric Protocols” on page 478, which tells the sad story of the derelict state of the numeric tower and a few existing shortcomings of the proposed alternative: the numeric static protocols such as SupportsFloat and others added to the typing module in Python 3.8. The main message of this chapter is that we have four comple"
    },
    "created_at": null
  },
  {
    "id": 1998,
    "question_text": "Print a welcome message with username",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "beginner",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_welcome",
      "sample_input": "('gamer123',)",
      "sample_output": "Welcome, gamer123! Ready to play?",
      "hidden_tests": [
        {
          "input": "('coder42',)",
          "expected_output": "Welcome, coder42! Ready to play?"
        },
        {
          "input": "('python_fan',)",
          "expected_output": "Welcome, python_fan! Ready to play?"
        }
      ],
      "buggy_code": "def print_welcome(username):\n    print('Welcome,')\n    print(username)\n    print('! Ready to play?')",
      "buggy_question_text": "The welcome message prints on separate lines instead of one",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 2009,
    "question_text": "Print a secret message with asterisk borders",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_secret_message",
      "sample_input": "('Hello World',)",
      "sample_output": "************\n*Hello World*\n************",
      "hidden_tests": [
        {
          "input": "('Python',)",
          "expected_output": "**********\n*Python*\n**********"
        },
        {
          "input": "('Debug',)",
          "expected_output": "********\n*Debug*\n********"
        }
      ],
      "buggy_code": "def print_secret_message(message):\n    border = '*' * len(message)\n    print(border)\n    print(f'*{message}*')\n    print(border)",
      "buggy_question_text": "Message prints without proper border formatting",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 2010,
    "question_text": "Print a formatted gamer tag with level",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_gamer_tag",
      "sample_input": "('Shadow', 25)",
      "sample_output": "Gamer: Shadow | Level: 25",
      "hidden_tests": [
        {
          "input": "('Ninja', 42)",
          "expected_output": "Gamer: Ninja | Level: 42"
        },
        {
          "input": "('ProGamer', 99)",
          "expected_output": "Gamer: ProGamer | Level: 99"
        }
      ],
      "buggy_code": "def print_gamer_tag(name, level):\n    print(f'Gamer:{name}|Level:{level}')",
      "buggy_question_text": "Gamer tag prints with incorrect spacing and formatting",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 2011,
    "question_text": "Print a social media post with hashtags",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_social_post",
      "sample_input": "('Learning Python!', ['coding', 'python'])",
      "sample_output": "Learning Python! #coding #python",
      "hidden_tests": [
        {
          "input": "('Debugging is fun', ['debug', 'programming'])",
          "expected_output": "Debugging is fun #debug #programming"
        },
        {
          "input": "('New project', ['dev', 'code'])",
          "expected_output": "New project #dev #code"
        }
      ],
      "buggy_code": "def print_social_post(text, hashtags):\n    print(text)\n    for tag in hashtags:\n        print(f'#{tag}')",
      "buggy_question_text": "Hashtags print on separate lines instead of together",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 2012,
    "question_text": "Print a progress bar with percentage",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_progress_bar",
      "sample_input": "(75,)",
      "sample_output": "[██████████░░░░░░░░] 75%",
      "hidden_tests": [
        {
          "input": "(50,)",
          "expected_output": "[██████████░░░░░░░░] 50%"
        },
        {
          "input": "(25,)",
          "expected_output": "[██████████░░░░░░░░] 25%"
        }
      ],
      "buggy_code": "def print_progress_bar(percent):\n    filled = '█' * (percent // 5)\n    empty = '░' * (20 - percent // 5)\n    print(f'[{filled}{empty}] {percent}%')",
      "buggy_question_text": "Progress bar shows incorrect percentage and formatting",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 2013,
    "question_text": "Print a multi-line address format",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Basic Input and Output",
    "subtopic": "Basic Text Output with print()",
    "game_data": {
      "function_name": "print_address",
      "sample_input": "('123 Main St', 'Springfield', 'IL', '62704')",
      "sample_output": "123 Main St\nSpringfield, IL 62704",
      "hidden_tests": [
        {
          "input": "('456 Oak Ave', 'Chicago', 'IL', '60601')",
          "expected_output": "456 Oak Ave\nChicago, IL 60601"
        },
        {
          "input": "('789 Pine Rd', 'New York', 'NY', '10001')",
          "expected_output": "789 Pine Rd\nNew York, NY 10001"
        }
      ],
      "buggy_code": "def print_address(street, city, state, zipcode):\n    print(f'{street}, {city}, {state} {zipcode}')",
      "buggy_question_text": "Address prints on one line instead of multiple lines",
      "subtopic_names": [
        "Basic Text Output with print()"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Basic Text Output with print()\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention establish"
    },
    "created_at": null
  },
  {
    "id": 2029,
    "question_text": "Create a user-friendly input validator for usernames",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Basic Input and Output",
    "subtopic": "Best Practices for User-Friendly I/O",
    "game_data": {
      "function_name": "validate_username",
      "sample_input": "('john_doe123',)",
      "sample_output": "True",
      "hidden_tests": [
        {
          "input": "('',)",
          "expected_output": "False"
        },
        {
          "input": "('user name',)",
          "expected_output": "False"
        },
        {
          "input": "('valid_user123',)",
          "expected_output": "True"
        }
      ],
      "buggy_code": "def validate_username(username):\n    if len(username) < 3:\n        return False\n    if ' ' in username:\n        return True\n    return username.isalnum()",
      "buggy_question_text": "Username validator crashes with empty input and allows spaces",
      "subtopic_names": [
        "Best Practices for User-Friendly I/O"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Best Practices for User-Friendly I/O\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention est"
    },
    "created_at": null
  },
  {
    "id": 2030,
    "question_text": "Build a formatted phone number display function",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Basic Input and Output",
    "subtopic": "Best Practices for User-Friendly I/O",
    "game_data": {
      "function_name": "format_phone_number",
      "sample_input": "('1234567890',)",
      "sample_output": "(123) 456-7890",
      "hidden_tests": [
        {
          "input": "('',)",
          "expected_output": "Invalid input"
        },
        {
          "input": "('123',)",
          "expected_output": "Invalid input"
        },
        {
          "input": "('5551234567',)",
          "expected_output": "(555) 123-4567"
        }
      ],
      "buggy_code": "def format_phone_number(phone):\n    if len(phone) != 10:\n        return phone\n    return f'({phone[:3]}) {phone[3:6]}-{phone[6:]}'",
      "buggy_question_text": "Phone formatter shows wrong format and crashes with invalid input",
      "subtopic_names": [
        "Best Practices for User-Friendly I/O"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Best Practices for User-Friendly I/O\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention est"
    },
    "created_at": null
  },
  {
    "id": 2031,
    "question_text": "Create a secure password strength checker",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Basic Input and Output",
    "subtopic": "Best Practices for User-Friendly I/O",
    "game_data": {
      "function_name": "check_password_strength",
      "sample_input": "('StrongPass123!',)",
      "sample_output": "Strong",
      "hidden_tests": [
        {
          "input": "('weak',)",
          "expected_output": "Weak"
        },
        {
          "input": "('Medium123',)",
          "expected_output": "Medium"
        },
        {
          "input": "('VeryStrong123!@#',)",
          "expected_output": "Very Strong"
        }
      ],
      "buggy_code": "def check_password_strength(password):\n    if len(password) < 8:\n        return 'Weak'\n    if any(c.isdigit() for c in password):\n        return 'Strong'\n    return 'Medium'",
      "buggy_question_text": "Password checker misses special characters and gives wrong feedback",
      "subtopic_names": [
        "Best Practices for User-Friendly I/O"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Best Practices for User-Friendly I/O\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention est"
    },
    "created_at": null
  },
  {
    "id": 2032,
    "question_text": "Implement a user-friendly date input parser",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Basic Input and Output",
    "subtopic": "Best Practices for User-Friendly I/O",
    "game_data": {
      "function_name": "parse_date_input",
      "sample_input": "('2023-12-25',)",
      "sample_output": "2023-12-25",
      "hidden_tests": [
        {
          "input": "('12/25/2023',)",
          "expected_output": "2023-12-25"
        },
        {
          "input": "('invalid',)",
          "expected_output": "Invalid date format"
        },
        {
          "input": "('25-12-2023',)",
          "expected_output": "2023-12-25"
        }
      ],
      "buggy_code": "def parse_date_input(date_str):\n    if '-' in date_str:\n        return date_str\n    elif '/' in date_str:\n        parts = date_str.split('/')\n        return f'{parts[2]}-{parts[0]}-{parts[1]}'\n    else:\n        return date_str",
      "buggy_question_text": "Date parser fails with different formats and invalid dates",
      "subtopic_names": [
        "Best Practices for User-Friendly I/O"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Best Practices for User-Friendly I/O\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention est"
    },
    "created_at": null
  },
  {
    "id": 2033,
    "question_text": "Create a smart input sanitizer for user comments",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Basic Input and Output",
    "subtopic": "Best Practices for User-Friendly I/O",
    "game_data": {
      "function_name": "sanitize_comment",
      "sample_input": "('Hello <script>alert()</script> world!',)",
      "sample_output": "Hello world!",
      "hidden_tests": [
        {
          "input": "('',)",
          "expected_output": "No comment provided"
        },
        {
          "input": "('Normal text here',)",
          "expected_output": "Normal text here"
        },
        {
          "input": "('<b>Bold</b> and <i>italic</i>',)",
          "expected_output": "Bold and italic"
        }
      ],
      "buggy_code": "def sanitize_comment(comment):\n    import re\n    if len(comment.strip()) == 0:\n        return comment\n    return re.sub(r'<.*?>', '', comment)",
      "buggy_question_text": "Comment sanitizer allows HTML tags and doesn't handle empty input",
      "subtopic_names": [
        "Best Practices for User-Friendly I/O"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Basic Input and Output\nSubtopic: Best Practices for User-Friendly I/O\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nIterator[T] is a shortcut for Generator[T, None, None]. Both annotations mean “a generator that yields items of type T, but that does not consume or return values.” Generators able to consume and return values are coroutines, our next topic.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Code ---\n520 | Chapter 15: More About Type Hints from typing import overload, Union, TypeVar T = TypeVar('T') S = TypeVar('S')\n\nDocument: Fluent Python\n--- Exercise ---\nSentence Classes with __iter__ The next variations of Sentence implement the standard iterable protocol, first by implementing the Iterator design pattern, and then with generator functions.\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nThis suggests that a good naming convention for covariant and contravariant type variables in Python would be: T_out = TypeVar('T_out', covariant=True) T_in = TypeVar('T_in', contravariant=True) Then we could define the classes like this: class BeverageDispenser(Generic[T_out]): ... class TrashCan(Generic[T_in]): ... Is it too late to change the naming convention est"
    },
    "created_at": null
  },
  {
    "id": 61,
    "question_text": "Check if Python version is 3.x",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "beginner",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Installing Python (Windows, macOS, Linux)",
    "game_data": {
      "function_name": "check_python_version",
      "sample_input": "()",
      "sample_output": "True",
      "hidden_tests": [
        {
          "input": "()",
          "expected_output": "True"
        }
      ],
      "buggy_code": "def check_python_version():\n    import sys\n    return sys.version.startswith('2')\n",
      "buggy_question_text": "Function returns True for Python 2.x versions incorrectly",
      "subtopic_names": [
        "Installing Python (Windows, macOS, Linux)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Installing Python (Windows, macOS, Linux)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 6\n\nLEARNING CONTENT:\n--- Concept ---\nWho This Book Is For This book was written for practicing Python programmers who want to become pro‐ ficient in Python 3. I tested the examples in Python 3.10—most of them also in Python 3.9 and 3.8. When an example requires Python 3.10, it should be clearly marked. If you are not sure whether you know enough Python to follow along, review the top‐ ics of the official Python tutorial. Topics covered in the tutorial will not be explained here, except for some features that are new.\n\nDocument: Fluent Python\n--- Concept ---\nThis book is not an A-to-Z exhaustive reference of Python. Its emphasis is on the lan‐ guage features that are either unique to Python or not found in many other popular languages. This is also mostly a book about the core language and some of its libra‐ ries. I will rarely talk about packages that are not in the standard library, even though the Python package index now lists more than 60,000 libraries, and many of them are incredibly useful. 1 Message to the comp.lang.python Usenet group, Dec. 23, 2002: “Acrimony in c.l.p”. xix\n\nDocument: Fluent Python\n--- Concept ---\nCovers Python 3.10 O'REILLY* Fluent Python Clear, Concise, and Effective Programming Luciano Ramalho Clear, Concise, and Effective Programming Luciano Ramalho O'REILLY*\n\nDocument: Fluent Python\n--- Concept ---\nMartelli and Ravenscroft were also technical reviewers of this book, along with Len‐ nart Regebro and Leonardo Rochael. Everyone in this outstanding technical review team has at least 15 years of Python experience, with many contributions to high- impact Python projects in close contact with other developers in the community. Together they sent me hundreds of corrections, suggestions, questions, and opinions, adding tremendous value to the book. Victor Stinner kindly reviewed Chapt"
    },
    "created_at": null
  },
  {
    "id": 62,
    "question_text": "Check if Python version meets minimum requirement",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Installing Python (Windows, macOS, Linux)",
    "game_data": {
      "function_name": "check_python_version",
      "sample_input": "('3.8',)",
      "sample_output": "True",
      "hidden_tests": [
        {
          "input": "('3.6',)",
          "expected_output": "False"
        },
        {
          "input": "('3.10',)",
          "expected_output": "True"
        },
        {
          "input": "('3.9',)",
          "expected_output": "True"
        }
      ],
      "buggy_code": "def check_python_version(min_version):\n    import sys\n    current = sys.version_info\n    required = tuple(map(int, min_version.split('.')))\n    return current[:2] >= required",
      "buggy_question_text": "Function returns incorrect boolean for version comparison",
      "subtopic_names": [
        "Installing Python (Windows, macOS, Linux)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Installing Python (Windows, macOS, Linux)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 6\n\nLEARNING CONTENT:\n--- Concept ---\nWho This Book Is For This book was written for practicing Python programmers who want to become pro‐ ficient in Python 3. I tested the examples in Python 3.10—most of them also in Python 3.9 and 3.8. When an example requires Python 3.10, it should be clearly marked. If you are not sure whether you know enough Python to follow along, review the top‐ ics of the official Python tutorial. Topics covered in the tutorial will not be explained here, except for some features that are new.\n\nDocument: Fluent Python\n--- Concept ---\nThis book is not an A-to-Z exhaustive reference of Python. Its emphasis is on the lan‐ guage features that are either unique to Python or not found in many other popular languages. This is also mostly a book about the core language and some of its libra‐ ries. I will rarely talk about packages that are not in the standard library, even though the Python package index now lists more than 60,000 libraries, and many of them are incredibly useful. 1 Message to the comp.lang.python Usenet group, Dec. 23, 2002: “Acrimony in c.l.p”. xix\n\nDocument: Fluent Python\n--- Concept ---\nCovers Python 3.10 O'REILLY* Fluent Python Clear, Concise, and Effective Programming Luciano Ramalho Clear, Concise, and Effective Programming Luciano Ramalho O'REILLY*\n\nDocument: Fluent Python\n--- Concept ---\nMartelli and Ravenscroft were also technical reviewers of this book, along with Len‐ nart Regebro and Leonardo Rochael. Everyone in this outstanding technical review team has at least 15 years of Python experience, with many contributions to high- impact Python projects in close contact with other developers in the community. Together they sent me hundreds of corrections, suggestions, questions, and opinions, adding tremendous value to the book. Victor Stinner kindly reviewed Chapt"
    },
    "created_at": null
  },
  {
    "id": 63,
    "question_text": "Check if Python version meets minimum requirement",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Installing Python (Windows, macOS, Linux)",
    "game_data": {
      "function_name": "check_python_version",
      "sample_input": "('3.10.0',)",
      "sample_output": "True",
      "hidden_tests": [
        {
          "input": "('3.8.5',)",
          "expected_output": "False"
        },
        {
          "input": "('3.10.6',)",
          "expected_output": "True"
        },
        {
          "input": "('3.11.2',)",
          "expected_output": "True"
        }
      ],
      "buggy_code": "def check_python_version(version_str):\n    major, minor, patch = version_str.split('.')\n    if int(major) == 3 and int(minor) >= 10:\n        return True\n    return False",
      "buggy_question_text": "Version check fails for valid Python 3.10 installations",
      "subtopic_names": [
        "Installing Python (Windows, macOS, Linux)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Installing Python (Windows, macOS, Linux)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 6\n\nLEARNING CONTENT:\n--- Concept ---\nWho This Book Is For This book was written for practicing Python programmers who want to become pro‐ ficient in Python 3. I tested the examples in Python 3.10—most of them also in Python 3.9 and 3.8. When an example requires Python 3.10, it should be clearly marked. If you are not sure whether you know enough Python to follow along, review the top‐ ics of the official Python tutorial. Topics covered in the tutorial will not be explained here, except for some features that are new.\n\nDocument: Fluent Python\n--- Concept ---\nThis book is not an A-to-Z exhaustive reference of Python. Its emphasis is on the lan‐ guage features that are either unique to Python or not found in many other popular languages. This is also mostly a book about the core language and some of its libra‐ ries. I will rarely talk about packages that are not in the standard library, even though the Python package index now lists more than 60,000 libraries, and many of them are incredibly useful. 1 Message to the comp.lang.python Usenet group, Dec. 23, 2002: “Acrimony in c.l.p”. xix\n\nDocument: Fluent Python\n--- Concept ---\nCovers Python 3.10 O'REILLY* Fluent Python Clear, Concise, and Effective Programming Luciano Ramalho Clear, Concise, and Effective Programming Luciano Ramalho O'REILLY*\n\nDocument: Fluent Python\n--- Concept ---\nMartelli and Ravenscroft were also technical reviewers of this book, along with Len‐ nart Regebro and Leonardo Rochael. Everyone in this outstanding technical review team has at least 15 years of Python experience, with many contributions to high- impact Python projects in close contact with other developers in the community. Together they sent me hundreds of corrections, suggestions, questions, and opinions, adding tremendous value to the book. Victor Stinner kindly reviewed Chapt"
    },
    "created_at": null
  },
  {
    "id": 64,
    "question_text": "Fix IDE setup function that validates Python version",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)",
    "game_data": {
      "function_name": "validate_python_version",
      "sample_input": "('3.10.0',)",
      "sample_output": "True",
      "hidden_tests": [
        {
          "input": "('3.7.0',)",
          "expected_output": "False"
        },
        {
          "input": "('3.11.2',)",
          "expected_output": "True"
        },
        {
          "input": "('2.7.18',)",
          "expected_output": "False"
        }
      ],
      "buggy_code": "def validate_python_version(version_str):\n    # Check if Python version is 3.10 or newer\n    major, minor, patch = version_str.split('.')\n    if major == '3' and minor >= '10':\n        return True\n    else:\n        return False",
      "buggy_question_text": "Function returns incorrect validation results for Python versions",
      "subtopic_names": [
        "Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 4\n\nLEARNING CONTENT:\n--- Concept ---\nCovers Python 3.10 O'REILLY* Fluent Python Clear, Concise, and Effective Programming Luciano Ramalho Clear, Concise, and Effective Programming Luciano Ramalho O'REILLY*\n\nDocument: Fluent Python\n--- Concept ---\nGradual Typing in Practice Let’s see how gradual typing works in practice, starting with a simple function and gradually adding type hints to it, guided by Mypy. There are several Python type checkers compatible with PEP 484, including Google’s pytype, Microsoft’s Pyright, Facebook’s Pyre— in addition to type checkers embedded in IDEs such as PyCharm. I picked Mypy for the examples because it’s the best known. How‐ ever, one of the others may be a better fit for some projects or teams. Pytype, for example, is designed to handle codebases with no type hints and still provide useful advice. It is more lenient than Mypy, and can also generate annotations for your code. 2 A just-in-time compiler like the one in PyPy has much better data than type hints: it monitors the Python program as it runs, detects the concrete types in use, and generates optimized machine code for those concrete types.\n\nDocument: Fluent Python\n--- Concept ---\nThe main beneficiaries are professional software engineers using IDEs (Integrated Development Environments) and CI (Continuous Integration). The cost-benefit analysis that makes type hints attractive to that group does not apply to all users of Python. Python’s user base is much wider than that. It includes scientists, traders, journalists, artists, makers, analysts, and students in many fields—among others. For most of them, the cost of learning type hints is likely higher—unless they already know a language with static types, subtyping, and generics. The benefits will be lower for many of those users, given how they interact"
    },
    "created_at": null
  },
  {
    "id": 65,
    "question_text": "Fix IDE configuration type hint validation",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "advanced",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)",
    "game_data": {
      "function_name": "validate_ide_config",
      "sample_input": "({'theme': 'dark', 'plugins': ['python', 'debugger'], 'version': 3.10},)",
      "sample_output": "{'theme': 'dark', 'plugins': ['python', 'debugger'], 'version': 3.10}",
      "hidden_tests": [
        {
          "input": "({'theme': 'light', 'plugins': [], 'version': 3.8},)",
          "expected_output": "{'theme': 'light', 'plugins': [], 'version': 3.8}"
        },
        {
          "input": "({'theme': 'system', 'plugins': ['linting', 'testing'], 'version': 3.11},)",
          "expected_output": "{'theme': 'system', 'plugins': ['linting', 'testing'], 'version': 3.11}"
        }
      ],
      "buggy_code": "def validate_ide_config(config: dict) -> dict:\n    if not isinstance(config, dict):\n        raise ValueError(\"Config must be a dictionary\")\n    \n    required = ['theme', 'plugins', 'version']\n    for key in required:\n        if key not in config:\n            config[key] = None\n    \n    if not isinstance(config['plugins'], list):\n        config['plugins'] = []\n    \n    return config",
      "buggy_question_text": "Type checker fails to validate IDE plugin settings correctly",
      "subtopic_names": [
        "Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 4\n\nLEARNING CONTENT:\n--- Concept ---\nCovers Python 3.10 O'REILLY* Fluent Python Clear, Concise, and Effective Programming Luciano Ramalho Clear, Concise, and Effective Programming Luciano Ramalho O'REILLY*\n\nDocument: Fluent Python\n--- Concept ---\nGradual Typing in Practice Let’s see how gradual typing works in practice, starting with a simple function and gradually adding type hints to it, guided by Mypy. There are several Python type checkers compatible with PEP 484, including Google’s pytype, Microsoft’s Pyright, Facebook’s Pyre— in addition to type checkers embedded in IDEs such as PyCharm. I picked Mypy for the examples because it’s the best known. How‐ ever, one of the others may be a better fit for some projects or teams. Pytype, for example, is designed to handle codebases with no type hints and still provide useful advice. It is more lenient than Mypy, and can also generate annotations for your code. 2 A just-in-time compiler like the one in PyPy has much better data than type hints: it monitors the Python program as it runs, detects the concrete types in use, and generates optimized machine code for those concrete types.\n\nDocument: Fluent Python\n--- Concept ---\nThe main beneficiaries are professional software engineers using IDEs (Integrated Development Environments) and CI (Continuous Integration). The cost-benefit analysis that makes type hints attractive to that group does not apply to all users of Python. Python’s user base is much wider than that. It includes scientists, traders, journalists, artists, makers, analysts, and students in many fields—among others. For most of them, the cost of learning type hints is likely higher—unless they already know a language with static types, subtyping, and generics. The benefits will be lower for many of those users, given how they interact"
    },
    "created_at": null
  },
  {
    "id": 66,
    "question_text": "Create a function that reverses a string and capitalizes the first letter",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "intermediate",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Writing and Running Your First Python Script",
    "game_data": {
      "function_name": "reverse_and_capitalize",
      "sample_input": "('hello world!',)",
      "sample_output": "!dlrow olleH",
      "hidden_tests": [
        {
          "input": "('python',)",
          "expected_output": "Nohtyp"
        },
        {
          "input": "('@test#',)",
          "expected_output": "#tset@"
        },
        {
          "input": "('',)",
          "expected_output": ""
        }
      ],
      "buggy_code": "def reverse_and_capitalize(s):\n    reversed_str = s[::-1]\n    if len(reversed_str) > 0:\n        if reversed_str[0].isalpha():\n            return reversed_str[0].upper() + reversed_str[1:]\n    return ''",
      "buggy_question_text": "Function returns empty string when input has special characters",
      "subtopic_names": [
        "Writing and Running Your First Python Script"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Writing and Running Your First Python Script\nGame Type: non_coding\nContent Types Found: Code, Exercise\nRetrieved Chunks: 7\n\nLEARNING CONTENT:\n--- Code ---\n…forcing us to import multiprocessing.synchronize… …to write this type hint. Basic usage of the Process class is similar to Thread. The spinner object is displayed as <Process name='Process-1' parent=14868 initial>, where 14868 is the process ID of the Python instance running spinner_proc.py. A Concurrent Hello World |\n\nDocument: Fluent Python\n--- Code ---\nSet Literals The syntax of set literals—{1}, {1, 2}, etc.—looks exactly like the math notation, with one important exception: there’s no literal notation for the empty set, so we must remember to write set().\n\nDocument: Fluent Python\n--- Code ---\nd.pop(k, [default]) Remove and return value at k, or default or None if missing d.popitem() Remove and return the last inserted item as (key, value) ® d.__reversed__() Support for reverse(d)—returns iterator for keys from last to first inserted.\n\nDocument: Fluent Python\n--- Code ---\nHere is an example invoking @lru_cache with nondefault parameters: @lru_cache(maxsize=2**20, typed=True) def costly_function(a, b): ... Now let’s study another powerful decorator: functools.singledispatch.\n\nDocument: Fluent Python\n--- Exercise ---\necorator basics, 304-306 decorator execution, 306 decorator implementation, 317-320 decorators in Python standard library, 320-323 enhancing classes with class decorators, 922-925 further reading on, 336 nonlocal declarations, 315-317 overview of, 336 parameterized decorators, 329-335 purpose of, 303 registration decorators, 308 significant changes to, 304 Soapbox discussion, 338-340 topics covered, 303 variable scope rules, 308-310\n\nDocument: Fluent Python\n--- Exercise ---\nIn other words, no other decorator may appear between @abstract method and the def statement. Now that we’ve got these ABC syntax issues covered, let’s put Tombola to use by im"
    },
    "created_at": null
  },
  {
    "id": 67,
    "question_text": "Fix IDE setup function that checks Python version",
    "correct_answer": "",
    "game_type": "coding",
    "difficulty": "beginner",
    "topic": "Introduction to Python & IDE Setup",
    "subtopic": "Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)",
    "game_data": {
      "function_name": "check_python_version",
      "sample_input": "(3, 8)",
      "sample_output": "Compatible with IDE",
      "hidden_tests": [
        {
          "input": "(3, 7)",
          "expected_output": "Upgrade required"
        },
        {
          "input": "(3, 9)",
          "expected_output": "Compatible with IDE"
        },
        {
          "input": "(3, 6)",
          "expected_output": "Upgrade required"
        }
      ],
      "buggy_code": "def check_python_version(major, minor):\n    if major == 3 and minor >= 8:\n        return \"Upgrade required\"\n    else:\n        return \"Compatible with IDE\"",
      "buggy_question_text": "Function returns incorrect Python version compatibility status",
      "subtopic_names": [
        "Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)"
      ],
      "zone_name": "Python Basics",
      "zone_order": 1,
      "rag_context": "Topic: Introduction to Python & IDE Setup\nSubtopic: Choosing and Setting Up an IDE (VS Code, PyCharm, etc.)\nGame Type: non_coding\nContent Types Found: Concept\nRetrieved Chunks: 4\n\nLEARNING CONTENT:\n--- Concept ---\nCovers Python 3.10 O'REILLY* Fluent Python Clear, Concise, and Effective Programming Luciano Ramalho Clear, Concise, and Effective Programming Luciano Ramalho O'REILLY*\n\nDocument: Fluent Python\n--- Concept ---\nGradual Typing in Practice Let’s see how gradual typing works in practice, starting with a simple function and gradually adding type hints to it, guided by Mypy. There are several Python type checkers compatible with PEP 484, including Google’s pytype, Microsoft’s Pyright, Facebook’s Pyre— in addition to type checkers embedded in IDEs such as PyCharm. I picked Mypy for the examples because it’s the best known. How‐ ever, one of the others may be a better fit for some projects or teams. Pytype, for example, is designed to handle codebases with no type hints and still provide useful advice. It is more lenient than Mypy, and can also generate annotations for your code. 2 A just-in-time compiler like the one in PyPy has much better data than type hints: it monitors the Python program as it runs, detects the concrete types in use, and generates optimized machine code for those concrete types.\n\nDocument: Fluent Python\n--- Concept ---\nThe main beneficiaries are professional software engineers using IDEs (Integrated Development Environments) and CI (Continuous Integration). The cost-benefit analysis that makes type hints attractive to that group does not apply to all users of Python. Python’s user base is much wider than that. It includes scientists, traders, journalists, artists, makers, analysts, and students in many fields—among others. For most of them, the cost of learning type hints is likely higher—unless they already know a language with static types, subtyping, and generics. The benefits will be lower for many of those users, given how they interact"
    },
    "created_at": null
  }
]